// Copyright (C) 2020-2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// Package sdk provides a comprehensive Go SDK for building and managing Lux blockchains
package sdk

import (
	"context"
	"fmt"

	"github.com/luxfi/sdk/blockchain"
	"github.com/luxfi/sdk/client"
	"github.com/luxfi/sdk/config"
	"github.com/luxfi/sdk/network"
	"github.com/luxfi/sdk/vm"
	"github.com/luxfi/log"
)

// LuxSDK is the main entrypoint for the Lux SDK
type LuxSDK struct {
	// CLI wrapper for command execution
	// cli *cli.CLI // TODO: Implement CLI wrapper
	
	// Core managers
	networkManager    *network.NetworkManager
	blockchainBuilder *blockchain.Builder
	vmManager         *vm.Manager
	
	// Configuration
	config *config.Config
	logger log.Logger
}

// New creates a new instance of the Lux SDK
func New(opts ...Option) (*LuxSDK, error) {
	// Apply options
	cfg := &config.Config{
		LogLevel: "info",
		DataDir:  "~/.lux",
	}
	
	for _, opt := range opts {
		opt(cfg)
	}
	
	// Initialize logger
	logger := logging.NewLogger(cfg.LogLevel)
	
	// Initialize CLI wrapper
	// TODO: Implement CLI wrapper
	// cliWrapper, err := cli.New(cli.Config{
	// 	DataDir:  cfg.DataDir,
	// 	LogLevel: cfg.LogLevel,
	// })
	// if err != nil {
	// 	return nil, fmt.Errorf("failed to initialize CLI: %w", err)
	// }
	
	// Initialize managers
	networkManager, err := network.NewNetworkManager(cfg.Network, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize network manager: %w", err)
	}
	
	blockchainBuilder := blockchain.NewBuilder(logger)
	vmManager := vm.NewManager(logger)
	
	return &LuxSDK{
		// cli:               cliWrapper,
		networkManager:    networkManager,
		blockchainBuilder: blockchainBuilder,
		vmManager:         vmManager,
		config:           cfg,
		logger:           logger,
	}, nil
}

// Option defines a configuration option for the SDK
type Option func(*config.Config)

// WithLogLevel sets the log level
func WithLogLevel(level string) Option {
	return func(cfg *config.Config) {
		cfg.LogLevel = level
	}
}

// WithDataDir sets the data directory
func WithDataDir(dir string) Option {
	return func(cfg *config.Config) {
		cfg.DataDir = dir
	}
}

// WithNetworkConfig sets the network configuration
func WithNetworkConfig(netCfg *config.NetworkConfig) Option {
	return func(cfg *config.Config) {
		cfg.Network = netCfg
	}
}

// Network Management

// CreateNetwork creates a new Lux network
func (sdk *LuxSDK) CreateNetwork(ctx context.Context, params *network.NetworkParams) (*network.Network, error) {
	return sdk.networkManager.CreateNetwork(ctx, params)
}

// StartNetwork starts a network
func (sdk *LuxSDK) StartNetwork(ctx context.Context, networkID string) error {
	return sdk.networkManager.StartNetwork(ctx, networkID)
}

// StopNetwork stops a network
func (sdk *LuxSDK) StopNetwork(ctx context.Context, networkID string) error {
	return sdk.networkManager.StopNetwork(ctx, networkID)
}

// GetNetwork gets network information
func (sdk *LuxSDK) GetNetwork(networkID string) (*network.Network, error) {
	return sdk.networkManager.GetNetwork(networkID)
}

// ListNetworks lists all networks
func (sdk *LuxSDK) ListNetworks() []*network.Network {
	return sdk.networkManager.ListNetworks()
}

// Blockchain Building

// CreateBlockchain creates a new blockchain
func (sdk *LuxSDK) CreateBlockchain(ctx context.Context, params *blockchain.CreateParams) (*blockchain.Blockchain, error) {
	return sdk.blockchainBuilder.CreateBlockchain(ctx, params)
}

// DeployBlockchain deploys a blockchain to a network
func (sdk *LuxSDK) DeployBlockchain(ctx context.Context, blockchainID, networkID string) error {
	blockchain, err := sdk.blockchainBuilder.GetBlockchain(blockchainID)
	if err != nil {
		return err
	}
	
	network, err := sdk.networkManager.GetNetwork(networkID)
	if err != nil {
		return err
	}
	
	return sdk.blockchainBuilder.Deploy(ctx, blockchain, network)
}

// VM Management

// CreateVM creates a new VM instance
func (sdk *LuxSDK) CreateVM(ctx context.Context, params *vm.CreateParams) (*vm.VM, error) {
	return sdk.vmManager.CreateVM(ctx, params)
}

// RegisterVM registers a custom VM
func (sdk *LuxSDK) RegisterVM(ctx context.Context, vm *vm.VM) error {
	return sdk.vmManager.RegisterVM(ctx, vm)
}

// Client Operations

// NewClient creates a new client for interacting with a Lux chain
func (sdk *LuxSDK) NewClient(endpoint string, opts ...client.Option) (*client.Client, error) {
	return client.New(endpoint, opts...)
}

// CLI Wrapper Methods

// ExecuteCommand executes a CLI command
func (sdk *LuxSDK) ExecuteCommand(ctx context.Context, command string, args ...string) (string, error) {
	// TODO: Implement CLI execution
	return "", fmt.Errorf("CLI execution not yet implemented")
}

// Chain Creation Helpers

// CreateL1 creates a new sovereign L1 chain
func (sdk *LuxSDK) CreateL1(ctx context.Context, name string, params *blockchain.L1Params) (*blockchain.Blockchain, error) {
	createParams := &blockchain.CreateParams{
		Name:        name,
		Type:        blockchain.TypeL1,
		VMType:      params.VMType,
		Genesis:     params.Genesis,
		ChainConfig: params.ChainConfig,
	}
	
	return sdk.CreateBlockchain(ctx, createParams)
}

// CreateL2 creates a new L2 (based rollup)
func (sdk *LuxSDK) CreateL2(ctx context.Context, name string, params *blockchain.L2Params) (*blockchain.Blockchain, error) {
	createParams := &blockchain.CreateParams{
		Name:        name,
		Type:        blockchain.TypeL2,
		VMType:      params.VMType,
		Genesis:     params.Genesis,
		ChainConfig: params.ChainConfig,
		L2Config: &blockchain.L2Config{
			SequencerType: params.SequencerType,
			DALayer:       params.DALayer,
			SettlementChain: params.SettlementChain,
		},
	}
	
	return sdk.CreateBlockchain(ctx, createParams)
}

// CreateL3 creates a new L3 (app chain on L2)
func (sdk *LuxSDK) CreateL3(ctx context.Context, name string, params *blockchain.L3Params) (*blockchain.Blockchain, error) {
	createParams := &blockchain.CreateParams{
		Name:        name,
		Type:        blockchain.TypeL3,
		VMType:      params.VMType,
		Genesis:     params.Genesis,
		ChainConfig: params.ChainConfig,
		L3Config: &blockchain.L3Config{
			L2Chain:     params.L2Chain,
			AppType:     params.AppType,
			AppConfig:   params.AppConfig,
		},
	}
	
	return sdk.CreateBlockchain(ctx, createParams)
}

// Utility Methods

// GenerateGenesis generates a genesis file for a blockchain
func (sdk *LuxSDK) GenerateGenesis(params *blockchain.GenesisParams) ([]byte, error) {
	return sdk.blockchainBuilder.GenerateGenesis(params)
}

// ValidateChainConfig validates a chain configuration
func (sdk *LuxSDK) ValidateChainConfig(config []byte) error {
	return sdk.blockchainBuilder.ValidateConfig(config)
}

// GetSupportedVMs returns a list of supported VM types
func (sdk *LuxSDK) GetSupportedVMs() []string {
	return sdk.vmManager.GetSupportedVMs()
}

// Close closes the SDK and cleans up resources
func (sdk *LuxSDK) Close() error {
	// Cleanup resources
	return nil
}